# @navihealth/widget-dashboard-ng5

widget-dashboard-ng5 is a library that will allow you to enable naviHealth's widget dashboard functionality to your application.

> This library is to be used in an Angular 5 application only. If your application is using something different, please look for a port or contact the Core Services team.

## Demo

To see a demo, add a host entry to your machine similar to this...

```
10.10.130.33 architectportaldemoapp
```

... where the ip address is the dev web server. Then go to http://architectportaldemoapp in your browser.

## Installation

npm install --save @navihealth/widget-dashboard-ng5

## Useful Commands For Devs

### To test the library.

```
npm run test
```

### To host the test harness locally.

```
npm run start
```

### To package the library.

```
npm run package
```

## Usage

### To import the DashboardModule into your module.

```typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { TesterComponent } from './tester.component';
import { DashboardModule } from '@navihealth/widget-dashboard-ng5';
import { WidgetsService } from './widgets.service';

@NgModule({
  declarations: [
    TesterComponent
  ],
  imports: [BrowserModule, DashboardModule.forRoot(WidgetsService)],
  providers: [],
  bootstrap: [TesterComponent]
})
export class TesterModule { }
```

Notice the import of <i>DashboardModule</i> and it's use in the imports property of the <i>NgModule</i> decorator.

A <i>WidgetsService</i> must be passed to the <i>DashboardModule</i> using the module's <i>forRoot</i> function. The <i>WidgetsService</i> class you create must implement the <i>IWidgetsService</i> interface. Here is an example implementation.

```typescript
import { Injectable } from '@angular/core';
import { Widget, IWidgetsService } from '@navihealth/widget-dashboard-ng5';
import * as ArchitectListWidgetNamespace from '@navihealth/architect-list-widget';
import * as ArchitectAddressWidgetNamespace from '@navihealth/architect-address-widget';
const ArchitectListWidget = (ArchitectListWidgetNamespace as any).default;
const ArchitectAddressWidget = (ArchitectAddressWidgetNamespace as any).default;

@Injectable()
export class WidgetsService implements IWidgetsService {
  constructor() { }

  getAvailableWidgets() {
    return [
      Widget.createAvailableWidget(ArchitectListWidget),
      Widget.createAvailableWidget(ArchitectAddressWidget)
    ];
  }

  getRenderedWidgets() {
    return [
      Widget.createRenderedWidget(Object.assign({}, ArchitectListWidget, {
        minimumWidth: ArchitectListWidget.width,
        currentWidth: Object.assign({}, ArchitectListWidget.width)
      })),
      Widget.createRenderedWidget(Object.assign({}, ArchitectAddressWidget, {
        minimumWidth: ArchitectAddressWidget.width,
        currentWidth: Object.assign({}, ArchitectListWidget.width)
      }))
    ];
  }
}
```

This class is the only place your installed widgets are imported. Those widgets are passed to at least one of two static factories on the <i>Widget</i> class, which is also imported from this library.

The <i>getAvailableWidgets</i> function returns the widgets that will be available in the library for the user to add to or remove from the dashboard. It uses the <i>createAvailableWidget</i> static factory on the <i>Widget</i> class.

The <i>getRenderedWidgets</i> function returns the widgets that are initially rendered when the dashboard is loaded. It uses the <i>createRenderedWidget</i> static factory on the <i>Widget</i> class.

> The general use case envisioned for a widget dashboard was that it would be supplied widgets that are created outside the dashboard's host application. This enables dashboards to be composed of an array of components from an array of business domains. However, technically, anything that satisfies the parameter of either of these two factories is a "widget" and can be used as such. If you define a local object that looks like a widget, it is one.

## What is a widget and what does one look like?

A widget, conceptually, is a relatively small chunk of JavaScript that has been created to render something in the UI. Whether it's a form or a read-only list of data or whatever doesn't matter too much technically. The widget can be shared with other applications that may use a different UI framework or version which is what sets it apart from the standard Angular Component.

> The general use case for widgets was described above, and again, there is flexability built-in to accomodate other use cases. A widget's <i>render</i> function can be called outside of a dashboard. Satisfy the same contract that the dashboard does by passing <i>render</i> an element already in the DOM, and you're all set. <b>Do not forget to design for latency while rendering the widget.</b>

### What contract must a widget satisfy?

Here is the simplest example of a widget...

```typescript
const id = 'c5d03052-1716-4dfb-a08a-76967051d4cf';
const title = 'Simple Widget';
const width = {
  xs: 12,
  sm: 4,
  md: 3,
  lg: 2,
  xl: 1
};
const initialHeight = '200px';
const render = async function(container: HTMLElement) {
  return new Promise(async (resolve, reject) => {
    try {
      const content = document.createElement('div');
      content.innerHTML = 'Hello Widget!';
      container.appendChild(content);
      resolve();
    } catch (error) {
      reject(error);
    }
  });
};

export default {
  id,
  title,
  width,
  initialHeight,
  render
};
```

The default export above satisfies the contract between a widget and the dashboard. Here is a description of each property...

* id - This must be a unique value. The dashboard will use it to persist the position that your widget should be rendered. You can find a website to generate a guid if that is most convenient.

* title - This is the title of your widget. The dashboard will use it to display the library of widgets available to the user.

* widget - This is the minimum and initial width of your widget. Notice that it is not a number, but an object that will look familiar if you're familiar with Bootstrap.

* initialHeight - This is the height of the placeholder the dashboard will render will it asynchronously waits for your widget to render. The UX would be best if this placeholder matches the actual height of your widget once it is fully rendered.

* render - This is the function that will render your widget. It takes the container that you'll append your widget into as an argument. It must return a promise to support async loading.

> An example of an Angular 4 widget can be found at https://bitbucket.navihealth.us/projects/SAN/repos/architectaddressdemowidget/browse/src/widget.ts.

> An example of an Angular 5 widget can be found at https://bitbucket.navihealth.us/projects/SAN/repos/architectlistdemowidget/browse/src/widget.ts.

### How can widgets communicate with one another?

You can use the @navihealth/browser-bus package to communicate between widgets. Information about its usage can be found at https://bitbucket.navihealth.us/projects/SAN/repos/browserbuslibrary/browse.

There are also examples in each of the demo widgets here...

https://bitbucket.navihealth.us/projects/SAN/repos/architectlistdemowidget/browse/src/app/app.component.ts

... and here...

https://bitbucket.navihealth.us/projects/SAN/repos/architectaddressdemowidget/browse/src/app/app.component.ts

> Look for imports of the BusFactory and track its use.

### Can you provide some advice to widget developers?

1. If you are using Angular, do not use a common name like app-root as your component selector. This could conflict with other widgets rendered on the same page.

2. Make sure to scope your style to your widget. In the outer-most HTML element in your widget add your widget's name as a class. Then in any other css you create include your widget's class name in the selector. For example, you need to create a .member css selector somewhere in your widget. Define it like this...

    ```
    .your-widgets-name .member { }
    ```

    This will apply your .member styles to elements only if they are descendants of .your-widgets-name.

    > Using the Angular 2+ <i>:host</i> is not enough for widgets. Instead, use <i>:host.your-widgets-name</i> in your component styles. Angular will reuse the values it associates with the keyword <i>:host</i> when it renders widgets. This will cause your style to leak.

3. If you follow the patterns suggested in the demo widget repos here...

    https://bitbucket.navihealth.us/projects/SAN/repos/architectlistdemowidget/browse

    ... and here...

    https://bitbucket.navihealth.us/projects/SAN/repos/architectaddressdemowidget/browse

    ... your project will include a main.ts and index.html, but they will not be used by the consumer of your widget. That makes these files good candidates for creating a manual test-harness. You can see an example in the Architect Address Demo Widget of a button being created in main.ts and used to simulate events being sent to @navihealth/browser-bus which the widget will listen for to display an address.

4. Determining the width your widget should export can be tricky. Your project should include an index.html to be used when testing even though it is not used when your widget is consumed by a dashboard. This index.html can be used to determine the exported width. For example, your <i>body</i> can look like this...

    ```
    <body>
      <div class='container-fluid'>
        <div class='row'>
          <div class='col-12 col-sm-8 col-md-6 col-lg-5 col-xl-4'>
            <div class='card card-row'>
              <div class='container'>
              </div>
            </div>
          </div>
        </div>
      </div>
    </body>
    ```

    Notice the Bootstrap <i>col-*</i> classes applied to one of the nested divs. Open your widget's test harness and resize your browser starting from large to small or vice versa. Make sure that at each breakpoint your widget renders properly. If it does not at a particular breakpoint, adjust the <i>col-*</i> classes above. Once each breakpoint is correct, those are the numbers you want to export.

    > You probably want to keep the widths to the lowest number that will render your widget properly. That way your widget does not take up more space on the dashboard than is necessary.

    > For this technique to work effectively, your index.html markup that wraps your widget should have the same styling applied to it as what the typical consumer of your widget will apply. This is to make sure margins and padding is factored in correctly. It's best to use the ESD stylesheet for this. Notice the use of the ESD's <i>card</i> and <i>card-row</i> classes above.