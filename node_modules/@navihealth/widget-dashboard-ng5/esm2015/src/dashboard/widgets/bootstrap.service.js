/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable } from '@angular/core';
export class BootstrapService {
    constructor() {
        this.maxColumns = 12;
        this.columnPrefix = 'col-';
        this.breakpoints = {
            xl: 'd-xl-none',
            lg: 'd-lg-none',
            md: 'd-md-none',
            sm: 'd-sm-none',
            xs: 'd-none'
        };
    }
    /**
     * @return {?}
     */
    getCurrentBreakpoint() {
        let /** @type {?} */ breakpoint = '';
        const /** @type {?} */ marker = document.createElement('div');
        marker.style.visibility = 'hidden';
        document.body.appendChild(marker);
        const /** @type {?} */ breakpointKeys = Object.keys(this.breakpoints);
        for (let /** @type {?} */ i = 0; i < breakpointKeys.length; i++) {
            breakpoint = breakpointKeys[i];
            marker.classList.add(this.breakpoints[breakpoint]);
            const /** @type {?} */ style = window.getComputedStyle(marker);
            if (style.display === 'none') {
                break;
            }
        }
        marker.remove();
        return breakpoint;
    }
    /**
     * @return {?}
     */
    hasBreakpointChanged() {
        const /** @type {?} */ breakpoint = this.getCurrentBreakpoint();
        if (breakpoint !== this.currentBreakpoint) {
            this.currentBreakpoint = breakpoint;
            return true;
        }
        return false;
    }
    /**
     * @param {?} getWidth
     * @return {?}
     */
    getWidth(getWidth) {
        let /** @type {?} */ breakpoint = this.getCurrentBreakpoint();
        let /** @type {?} */ width = getWidth(breakpoint);
        if (!width) {
            // Look for the largest breakpoint with a width that is smaller than the current breakpoint.
            const /** @type {?} */ smallerBreakpoints = this.getSmallerBreakpoints(breakpoint);
            while (!width && smallerBreakpoints.length) {
                breakpoint = smallerBreakpoints.shift();
                width = getWidth(breakpoint);
            }
        }
        return width;
    }
    /**
     * @param {?} makeFullWidth
     * @return {?}
     */
    makeFullWidth(makeFullWidth) {
        const /** @type {?} */ breakpoint = this.getCurrentBreakpoint();
        // Make each breakpoint at the current size and smaller the full width of a row.
        this.getSmallerBreakpoints(breakpoint)
            .concat([breakpoint])
            .forEach(x => {
            makeFullWidth(x, this.maxColumns);
        });
    }
    /**
     * @param {?} widget
     * @param {?} targetWidthOfWidget
     * @return {?}
     */
    resize(widget, targetWidthOfWidget) {
        let /** @type {?} */ breakpoint = this.getCurrentBreakpoint();
        let /** @type {?} */ width = widget.getCurrentWidth(breakpoint);
        if (!width) {
            // Look for the largest breakpoint with a width that is smaller than the current breakpoint.
            const /** @type {?} */ smallerBreakpoints = this.getSmallerBreakpoints(breakpoint);
            while (!width && smallerBreakpoints.length) {
                breakpoint = smallerBreakpoints.shift();
                width = widget.getCurrentWidth(breakpoint);
            }
        }
        widget.resize(breakpoint, targetWidthOfWidget);
    }
    /**
     * @param {?} widget
     * @return {?}
     */
    getClasses(widget) {
        const /** @type {?} */ widths = widget.getCurrentWidths();
        return Object.keys(widths)
            .map(x => {
            const /** @type {?} */ width = widths[x];
            if (x === 'xs') {
                return 'col-' + width;
            }
            return 'col-' + x + '-' + width;
        });
    }
    /**
     * @param {?} breakpoint
     * @return {?}
     */
    getSmallerBreakpoints(breakpoint) {
        const /** @type {?} */ allBreakpoints = Object.keys(this.breakpoints);
        const /** @type {?} */ smallerBreakpoints = allBreakpoints.slice(allBreakpoints.indexOf(breakpoint) + 1, allBreakpoints.length);
        return smallerBreakpoints;
    }
}
BootstrapService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
BootstrapService.ctorParameters = () => [];
function BootstrapService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    BootstrapService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    BootstrapService.ctorParameters;
    /** @type {?} */
    BootstrapService.prototype.maxColumns;
    /** @type {?} */
    BootstrapService.prototype.columnPrefix;
    /** @type {?} */
    BootstrapService.prototype.breakpoints;
    /** @type {?} */
    BootstrapService.prototype.currentBreakpoint;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmF2aWhlYWx0aC93aWRnZXQtZGFzaGJvYXJkLW5nNS8iLCJzb3VyY2VzIjpbInNyYy9kYXNoYm9hcmQvd2lkZ2V0cy9ib290c3RyYXAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUkzQyxNQUFNO0lBY0o7MEJBYnNCLEVBQUU7NEJBQ0EsTUFBTTsyQkFHQztZQUM3QixFQUFFLEVBQUUsV0FBVztZQUNmLEVBQUUsRUFBRSxXQUFXO1lBQ2YsRUFBRSxFQUFFLFdBQVc7WUFDZixFQUFFLEVBQUUsV0FBVztZQUNmLEVBQUUsRUFBRSxRQUFRO1NBQ2I7S0FHZ0I7Ozs7SUFLVCxvQkFBb0I7UUFDMUIscUJBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUVwQix1QkFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUM7UUFDbkMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEMsdUJBQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXJELEdBQUcsQ0FBQyxDQUFDLHFCQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMvQyxVQUFVLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNuRCx1QkFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixD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O2FBQ3ZCO1lBQ0QsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQztTQUNqQyxDQUFDLENBQUM7S0FDTjs7Ozs7SUFFTyxxQkFBcUIsQ0FBQyxVQUFVO1FBQ3RDLHVCQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNyRCx1QkFBTSxrQkFBa0IsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUM3QyxjQUFjLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFDdEMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pCLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQzs7OztZQXpHN0IsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgV2lkZ2V0IH0gZnJvbSAnLi93aWRnZXQubW9kZWwnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwU2VydmljZSB7XHJcbiAgcmVhZG9ubHkgbWF4Q29sdW1ucyA9IDEyO1xyXG4gIHJlYWRvbmx5IGNvbHVtblByZWZpeCA9ICdjb2wtJztcclxuXHJcbiAgLy8gVGhlc2UgbXVzdCByZW1haW4gaW4gb3JkZXIgZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0LlxyXG4gIHByaXZhdGUgcmVhZG9ubHkgYnJlYWtwb2ludHMgPSB7XHJcbiAgICB4bDogJ2QteGwtbm9uZScsXHJcbiAgICBsZzogJ2QtbGctbm9uZScsXHJcbiAgICBtZDogJ2QtbWQtbm9uZScsXHJcbiAgICBzbTogJ2Qtc20tbm9uZScsXHJcbiAgICB4czogJ2Qtbm9uZSdcclxuICB9O1xyXG4gIHByaXZhdGUgY3VycmVudEJyZWFrcG9pbnQ6IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7IH1cclxuXHJcbiAgLy8gQWRkIGFuIGVsZW1lbnQgdG8gdGhlIERPTSBhbmQgc2V0IGl0J3MgY2xhc3MgdG8gcHJldmVudCBpdCBmcm9tIGRpc3BsYXlpbmdcclxuICAvLyBhdCBlYWNoIGJyZWFrcG9pbnQgdW50aWwgaXQgaXMsIGluIGZhY3QsIG5vdCBkaXNwbGF5ZWQuIFRoYXQgaXMgdGhlIHNpemUgb2ZcclxuICAvLyB0aGUgc2NyZWVuLlxyXG4gIHByaXZhdGUgZ2V0Q3VycmVudEJyZWFrcG9pbnQoKTogc3RyaW5nIHtcclxuICAgIGxldCBicmVha3BvaW50ID0gJyc7XHJcblxyXG4gICAgY29uc3QgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBtYXJrZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtYXJrZXIpO1xyXG4gICAgY29uc3QgYnJlYWtwb2ludEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmJyZWFrcG9pbnRzKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyZWFrcG9pbnRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGJyZWFrcG9pbnQgPSBicmVha3BvaW50S2V5c1tpXTtcclxuICAgICAgbWFya2VyLmNsYXNzTGlzdC5hZGQodGhpcy5icmVha3BvaW50c1ticmVha3BvaW50XSk7XHJcbiAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobWFya2VyKTtcclxuICAgICAgaWYgKHN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWFya2VyLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIGJyZWFrcG9pbnQ7XHJcbiAgfVxyXG5cclxuICBoYXNCcmVha3BvaW50Q2hhbmdlZCgpIHtcclxuICAgIGNvbnN0IGJyZWFrcG9pbnQ6IHN0cmluZyA9IHRoaXMuZ2V0Q3VycmVudEJyZWFrcG9pbnQoKTtcclxuICAgIGlmIChicmVha3BvaW50ICE9PSB0aGlzLmN1cnJlbnRCcmVha3BvaW50KSB7XHJcbiAgICAgIHRoaXMuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGdldFdpZHRoKGdldFdpZHRoOiAoc3RyaW5nKSA9PiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgbGV0IGJyZWFrcG9pbnQgPSB0aGlzLmdldEN1cnJlbnRCcmVha3BvaW50KCk7XHJcbiAgICBsZXQgd2lkdGggPSBnZXRXaWR0aChicmVha3BvaW50KTtcclxuICAgIGlmICghd2lkdGgpIHtcclxuICAgICAgLy8gTG9vayBmb3IgdGhlIGxhcmdlc3QgYnJlYWtwb2ludCB3aXRoIGEgd2lkdGggdGhhdCBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgYnJlYWtwb2ludC5cclxuICAgICAgY29uc3Qgc21hbGxlckJyZWFrcG9pbnRzID0gdGhpcy5nZXRTbWFsbGVyQnJlYWtwb2ludHMoYnJlYWtwb2ludCk7XHJcbiAgICAgIHdoaWxlICghd2lkdGggJiYgc21hbGxlckJyZWFrcG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGJyZWFrcG9pbnQgPSBzbWFsbGVyQnJlYWtwb2ludHMuc2hpZnQoKTtcclxuICAgICAgICB3aWR0aCA9IGdldFdpZHRoKGJyZWFrcG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbiAgfVxyXG5cclxuICBtYWtlRnVsbFdpZHRoKG1ha2VGdWxsV2lkdGg6IChzdHJpbmcsIG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgY29uc3QgYnJlYWtwb2ludCA9IHRoaXMuZ2V0Q3VycmVudEJyZWFrcG9pbnQoKTtcclxuICAgIC8vIE1ha2UgZWFjaCBicmVha3BvaW50IGF0IHRoZSBjdXJyZW50IHNpemUgYW5kIHNtYWxsZXIgdGhlIGZ1bGwgd2lkdGggb2YgYSByb3cuXHJcbiAgICB0aGlzLmdldFNtYWxsZXJCcmVha3BvaW50cyhicmVha3BvaW50KVxyXG4gICAgICAuY29uY2F0KFticmVha3BvaW50XSlcclxuICAgICAgLmZvckVhY2goeCA9PiB7XHJcbiAgICAgICAgbWFrZUZ1bGxXaWR0aCh4LCB0aGlzLm1heENvbHVtbnMpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHJlc2l6ZSh3aWRnZXQ6IFdpZGdldCwgdGFyZ2V0V2lkdGhPZldpZGdldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsZXQgYnJlYWtwb2ludCA9IHRoaXMuZ2V0Q3VycmVudEJyZWFrcG9pbnQoKTtcclxuICAgIGxldCB3aWR0aCA9IHdpZGdldC5nZXRDdXJyZW50V2lkdGgoYnJlYWtwb2ludCk7XHJcbiAgICBpZiAoIXdpZHRoKSB7XHJcbiAgICAgIC8vIExvb2sgZm9yIHRoZSBsYXJnZXN0IGJyZWFrcG9pbnQgd2l0aCBhIHdpZHRoIHRoYXQgaXMgc21hbGxlciB0aGFuIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQuXHJcbiAgICAgIGNvbnN0IHNtYWxsZXJCcmVha3BvaW50cyA9IHRoaXMuZ2V0U21hbGxlckJyZWFrcG9pbnRzKGJyZWFrcG9pbnQpO1xyXG4gICAgICB3aGlsZSAoIXdpZHRoICYmIHNtYWxsZXJCcmVha3BvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICBicmVha3BvaW50ID0gc21hbGxlckJyZWFrcG9pbnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgd2lkdGggPSB3aWRnZXQuZ2V0Q3VycmVudFdpZHRoKGJyZWFrcG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB3aWRnZXQucmVzaXplKGJyZWFrcG9pbnQsIHRhcmdldFdpZHRoT2ZXaWRnZXQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2xhc3Nlcyh3aWRnZXQ6IFdpZGdldCk6IHN0cmluZ1tdIHtcclxuICAgIGNvbnN0IHdpZHRocyA9IHdpZGdldC5nZXRDdXJyZW50V2lkdGhzKCk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMod2lkdGhzKVxyXG4gICAgICAubWFwKHggPT4ge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2lkdGhzW3hdO1xyXG4gICAgICAgIGlmICh4ID09PSAneHMnKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ2NvbC0nICsgd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnY29sLScgKyB4ICsgJy0nICsgd2lkdGg7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRTbWFsbGVyQnJlYWtwb2ludHMoYnJlYWtwb2ludCk6IHN0cmluZ1tdIHtcclxuICAgIGNvbnN0IGFsbEJyZWFrcG9pbnRzID0gT2JqZWN0LmtleXModGhpcy5icmVha3BvaW50cyk7XHJcbiAgICBjb25zdCBzbWFsbGVyQnJlYWtwb2ludHMgPSBhbGxCcmVha3BvaW50cy5zbGljZShcclxuICAgICAgYWxsQnJlYWtwb2ludHMuaW5kZXhPZihicmVha3BvaW50KSArIDEsXHJcbiAgICAgIGFsbEJyZWFrcG9pbnRzLmxlbmd0aCk7XHJcbiAgICByZXR1cm4gc21hbGxlckJyZWFrcG9pbnRzO1xyXG4gIH1cclxufVxyXG4iXX0=